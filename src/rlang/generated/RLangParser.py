# Generated from E:/Term7/Compiler/Project/RLangCompiler/grammers/RLang.g4 by ANTLR 4.13.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO

def serializedATN():
    return [
        4,1,40,272,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,
        6,2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,
        2,14,7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,
        7,20,1,0,1,0,1,0,1,1,1,1,1,1,1,1,1,1,1,1,3,1,52,8,1,1,1,3,1,55,8,
        1,1,1,3,1,58,8,1,1,1,1,1,1,2,1,2,1,2,5,2,65,8,2,10,2,12,2,68,9,2,
        1,2,1,2,1,3,1,3,1,3,1,3,1,3,1,3,1,4,1,4,3,4,80,8,4,1,5,1,5,1,5,1,
        5,5,5,86,8,5,10,5,12,5,89,9,5,3,5,91,8,5,1,5,1,5,1,5,1,5,1,5,5,5,
        98,8,5,10,5,12,5,101,9,5,3,5,103,8,5,1,5,3,5,106,8,5,1,6,1,6,1,6,
        1,6,1,6,5,6,113,8,6,10,6,12,6,116,9,6,3,6,118,8,6,1,6,1,6,1,7,1,
        7,1,7,5,7,125,8,7,10,7,12,7,128,9,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,
        1,8,1,8,1,8,1,8,1,8,1,8,1,8,1,8,3,8,145,8,8,1,9,5,9,148,8,9,10,9,
        12,9,151,9,9,1,10,1,10,3,10,155,8,10,1,10,1,10,3,10,159,8,10,1,10,
        1,10,3,10,163,8,10,1,10,1,10,1,10,1,10,3,10,169,8,10,1,11,1,11,1,
        11,1,11,3,11,175,8,11,1,12,1,12,1,12,1,12,1,12,1,12,1,13,1,13,1,
        13,1,13,5,13,187,8,13,10,13,12,13,190,9,13,1,13,1,13,1,14,1,14,1,
        14,1,14,1,14,1,15,1,15,1,15,5,15,202,8,15,10,15,12,15,205,9,15,1,
        15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,17,1,17,1,17,5,
        17,220,8,17,10,17,12,17,223,9,17,1,17,1,17,1,18,1,18,1,18,1,18,1,
        18,1,19,1,19,1,19,1,19,1,19,1,19,5,19,238,8,19,10,19,12,19,241,9,
        19,3,19,243,8,19,1,19,1,19,1,19,1,19,1,19,3,19,250,8,19,1,20,1,20,
        1,20,1,20,1,20,1,20,1,20,3,20,259,8,20,1,20,1,20,1,20,1,20,1,20,
        1,20,5,20,267,8,20,10,20,12,20,270,9,20,1,20,0,1,40,21,0,2,4,6,8,
        10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,0,3,1,0,29,32,1,
        0,35,36,1,0,33,34,282,0,42,1,0,0,0,2,45,1,0,0,0,4,61,1,0,0,0,6,71,
        1,0,0,0,8,79,1,0,0,0,10,105,1,0,0,0,12,107,1,0,0,0,14,121,1,0,0,
        0,16,144,1,0,0,0,18,149,1,0,0,0,20,168,1,0,0,0,22,170,1,0,0,0,24,
        176,1,0,0,0,26,182,1,0,0,0,28,193,1,0,0,0,30,198,1,0,0,0,32,208,
        1,0,0,0,34,216,1,0,0,0,36,226,1,0,0,0,38,249,1,0,0,0,40,258,1,0,
        0,0,42,43,3,2,1,0,43,44,5,0,0,1,44,1,1,0,0,0,45,46,5,1,0,0,46,47,
        5,15,0,0,47,48,5,24,0,0,48,49,3,4,2,0,49,51,3,12,6,0,50,52,3,14,
        7,0,51,50,1,0,0,0,51,52,1,0,0,0,52,54,1,0,0,0,53,55,3,30,15,0,54,
        53,1,0,0,0,54,55,1,0,0,0,55,57,1,0,0,0,56,58,3,34,17,0,57,56,1,0,
        0,0,57,58,1,0,0,0,58,59,1,0,0,0,59,60,5,25,0,0,60,3,1,0,0,0,61,62,
        5,2,0,0,62,66,5,24,0,0,63,65,3,6,3,0,64,63,1,0,0,0,65,68,1,0,0,0,
        66,64,1,0,0,0,66,67,1,0,0,0,67,69,1,0,0,0,68,66,1,0,0,0,69,70,5,
        25,0,0,70,5,1,0,0,0,71,72,5,15,0,0,72,73,5,18,0,0,73,74,3,8,4,0,
        74,75,3,10,5,0,75,76,5,20,0,0,76,7,1,0,0,0,77,80,5,13,0,0,78,80,
        5,14,0,0,79,77,1,0,0,0,79,78,1,0,0,0,80,9,1,0,0,0,81,90,5,22,0,0,
        82,87,3,40,20,0,83,84,5,21,0,0,84,86,3,40,20,0,85,83,1,0,0,0,86,
        89,1,0,0,0,87,85,1,0,0,0,87,88,1,0,0,0,88,91,1,0,0,0,89,87,1,0,0,
        0,90,82,1,0,0,0,90,91,1,0,0,0,91,92,1,0,0,0,92,106,5,23,0,0,93,102,
        5,26,0,0,94,99,3,40,20,0,95,96,5,21,0,0,96,98,3,40,20,0,97,95,1,
        0,0,0,98,101,1,0,0,0,99,97,1,0,0,0,99,100,1,0,0,0,100,103,1,0,0,
        0,101,99,1,0,0,0,102,94,1,0,0,0,102,103,1,0,0,0,103,104,1,0,0,0,
        104,106,5,27,0,0,105,81,1,0,0,0,105,93,1,0,0,0,106,11,1,0,0,0,107,
        108,5,4,0,0,108,117,5,24,0,0,109,114,5,15,0,0,110,111,5,21,0,0,111,
        113,5,15,0,0,112,110,1,0,0,0,113,116,1,0,0,0,114,112,1,0,0,0,114,
        115,1,0,0,0,115,118,1,0,0,0,116,114,1,0,0,0,117,109,1,0,0,0,117,
        118,1,0,0,0,118,119,1,0,0,0,119,120,5,25,0,0,120,13,1,0,0,0,121,
        122,5,5,0,0,122,126,5,24,0,0,123,125,3,16,8,0,124,123,1,0,0,0,125,
        128,1,0,0,0,126,124,1,0,0,0,126,127,1,0,0,0,127,129,1,0,0,0,128,
        126,1,0,0,0,129,130,5,25,0,0,130,15,1,0,0,0,131,132,5,8,0,0,132,
        133,5,24,0,0,133,134,3,18,9,0,134,135,5,25,0,0,135,145,1,0,0,0,136,
        137,5,9,0,0,137,138,5,22,0,0,138,139,3,38,19,0,139,140,5,23,0,0,
        140,141,5,24,0,0,141,142,3,18,9,0,142,143,5,25,0,0,143,145,1,0,0,
        0,144,131,1,0,0,0,144,136,1,0,0,0,145,17,1,0,0,0,146,148,3,20,10,
        0,147,146,1,0,0,0,148,151,1,0,0,0,149,147,1,0,0,0,149,150,1,0,0,
        0,150,19,1,0,0,0,151,149,1,0,0,0,152,154,3,22,11,0,153,155,5,20,
        0,0,154,153,1,0,0,0,154,155,1,0,0,0,155,169,1,0,0,0,156,158,3,24,
        12,0,157,159,5,20,0,0,158,157,1,0,0,0,158,159,1,0,0,0,159,169,1,
        0,0,0,160,162,3,26,13,0,161,163,5,20,0,0,162,161,1,0,0,0,162,163,
        1,0,0,0,163,169,1,0,0,0,164,165,5,24,0,0,165,166,3,18,9,0,166,167,
        5,25,0,0,167,169,1,0,0,0,168,152,1,0,0,0,168,156,1,0,0,0,168,160,
        1,0,0,0,168,164,1,0,0,0,169,21,1,0,0,0,170,171,5,15,0,0,171,172,
        5,19,0,0,172,174,3,40,20,0,173,175,5,20,0,0,174,173,1,0,0,0,174,
        175,1,0,0,0,175,23,1,0,0,0,176,177,5,11,0,0,177,178,5,22,0,0,178,
        179,3,38,19,0,179,180,5,23,0,0,180,181,3,20,10,0,181,25,1,0,0,0,
        182,183,5,10,0,0,183,184,5,3,0,0,184,188,5,24,0,0,185,187,3,28,14,
        0,186,185,1,0,0,0,187,190,1,0,0,0,188,186,1,0,0,0,188,189,1,0,0,
        0,189,191,1,0,0,0,190,188,1,0,0,0,191,192,5,25,0,0,192,27,1,0,0,
        0,193,194,5,15,0,0,194,195,5,28,0,0,195,196,3,20,10,0,196,197,5,
        20,0,0,197,29,1,0,0,0,198,199,5,6,0,0,199,203,5,24,0,0,200,202,3,
        32,16,0,201,200,1,0,0,0,202,205,1,0,0,0,203,201,1,0,0,0,203,204,
        1,0,0,0,204,206,1,0,0,0,205,203,1,0,0,0,206,207,5,25,0,0,207,31,
        1,0,0,0,208,209,5,11,0,0,209,210,5,22,0,0,210,211,3,38,19,0,211,
        212,5,23,0,0,212,213,5,28,0,0,213,214,3,40,20,0,214,215,5,20,0,0,
        215,33,1,0,0,0,216,217,5,7,0,0,217,221,5,24,0,0,218,220,3,36,18,
        0,219,218,1,0,0,0,220,223,1,0,0,0,221,219,1,0,0,0,221,222,1,0,0,
        0,222,224,1,0,0,0,223,221,1,0,0,0,224,225,5,25,0,0,225,35,1,0,0,
        0,226,227,5,15,0,0,227,228,5,18,0,0,228,229,3,40,20,0,229,230,5,
        20,0,0,230,37,1,0,0,0,231,232,5,15,0,0,232,233,5,12,0,0,233,242,
        5,26,0,0,234,239,3,40,20,0,235,236,5,21,0,0,236,238,3,40,20,0,237,
        235,1,0,0,0,238,241,1,0,0,0,239,237,1,0,0,0,239,240,1,0,0,0,240,
        243,1,0,0,0,241,239,1,0,0,0,242,234,1,0,0,0,242,243,1,0,0,0,243,
        244,1,0,0,0,244,250,5,27,0,0,245,246,3,40,20,0,246,247,7,0,0,0,247,
        248,3,40,20,0,248,250,1,0,0,0,249,231,1,0,0,0,249,245,1,0,0,0,250,
        39,1,0,0,0,251,252,6,20,-1,0,252,259,5,15,0,0,253,259,5,16,0,0,254,
        255,5,22,0,0,255,256,3,40,20,0,256,257,5,23,0,0,257,259,1,0,0,0,
        258,251,1,0,0,0,258,253,1,0,0,0,258,254,1,0,0,0,259,268,1,0,0,0,
        260,261,10,5,0,0,261,262,7,1,0,0,262,267,3,40,20,6,263,264,10,4,
        0,0,264,265,7,2,0,0,265,267,3,40,20,5,266,260,1,0,0,0,266,263,1,
        0,0,0,267,270,1,0,0,0,268,266,1,0,0,0,268,269,1,0,0,0,269,41,1,0,
        0,0,270,268,1,0,0,0,29,51,54,57,66,79,87,90,99,102,105,114,117,126,
        144,149,154,158,162,168,174,188,203,221,239,242,249,258,266,268
    ]

class RLangParser ( Parser ):

    grammarFileName = "RLang.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'ENVIRONMENT'", "'STATE'", "'ACTION'", 
                     "'ACTIONS'", "'DYNAMICS'", "'REWARDS'", "'TRAINING'", 
                     "'always'", "'when'", "'match'", "'if'", "'in'", "'continuous'", 
                     "'discrete'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "':'", "'='", "';'", "','", "'('", "')'", "'{'", "'}'", 
                     "'['", "']'", "'->'", "'=='", "'!='", "'>'", "'<'", 
                     "'+'", "'-'", "'*'", "'/'", "'&'", "'|'" ]

    symbolicNames = [ "<INVALID>", "KEYWORD_ENV", "KEYWORD_STATE", "KEYWORD_ACTION", 
                      "KEYWORD_ACTIONS", "KEYWORD_DYNAMICS", "KEYWORD_REWARDS", 
                      "KEYWORD_TRAINING", "KEYWORD_ALWAYS", "KEYWORD_WHEN", 
                      "KEYWORD_MATCH", "KEYWORD_IF", "IN", "TYPE_CONT", 
                      "TYPE_DISC", "ID", "NUMBER", "STRING", "ASSIGN_COLON", 
                      "ASSIGN_EQ", "SEMI", "COMMA", "LPAREN", "RPAREN", 
                      "LBRACE", "RBRACE", "LBRACK", "RBRACK", "ARROW", "EQ", 
                      "NEQ", "GT", "LT", "PLUS", "MINUS", "MUL", "DIV", 
                      "AND", "OR", "WS", "COMMENT" ]

    RULE_prog = 0
    RULE_environmentDef = 1
    RULE_stateDef = 2
    RULE_varDecl = 3
    RULE_type = 4
    RULE_paramList = 5
    RULE_actionsDef = 6
    RULE_dynamicsDef = 7
    RULE_dynamicsRule = 8
    RULE_statementList = 9
    RULE_statement = 10
    RULE_assignment = 11
    RULE_ifStatement = 12
    RULE_matchStatement = 13
    RULE_matchCase = 14
    RULE_rewardsDef = 15
    RULE_rewardRule = 16
    RULE_trainingDef = 17
    RULE_configAssign = 18
    RULE_condition = 19
    RULE_expr = 20

    ruleNames =  [ "prog", "environmentDef", "stateDef", "varDecl", "type", 
                   "paramList", "actionsDef", "dynamicsDef", "dynamicsRule", 
                   "statementList", "statement", "assignment", "ifStatement", 
                   "matchStatement", "matchCase", "rewardsDef", "rewardRule", 
                   "trainingDef", "configAssign", "condition", "expr" ]

    EOF = Token.EOF
    KEYWORD_ENV=1
    KEYWORD_STATE=2
    KEYWORD_ACTION=3
    KEYWORD_ACTIONS=4
    KEYWORD_DYNAMICS=5
    KEYWORD_REWARDS=6
    KEYWORD_TRAINING=7
    KEYWORD_ALWAYS=8
    KEYWORD_WHEN=9
    KEYWORD_MATCH=10
    KEYWORD_IF=11
    IN=12
    TYPE_CONT=13
    TYPE_DISC=14
    ID=15
    NUMBER=16
    STRING=17
    ASSIGN_COLON=18
    ASSIGN_EQ=19
    SEMI=20
    COMMA=21
    LPAREN=22
    RPAREN=23
    LBRACE=24
    RBRACE=25
    LBRACK=26
    RBRACK=27
    ARROW=28
    EQ=29
    NEQ=30
    GT=31
    LT=32
    PLUS=33
    MINUS=34
    MUL=35
    DIV=36
    AND=37
    OR=38
    WS=39
    COMMENT=40

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.13.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def environmentDef(self):
            return self.getTypedRuleContext(RLangParser.EnvironmentDefContext,0)


        def EOF(self):
            return self.getToken(RLangParser.EOF, 0)

        def getRuleIndex(self):
            return RLangParser.RULE_prog

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProg" ):
                listener.enterProg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProg" ):
                listener.exitProg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProg" ):
                return visitor.visitProg(self)
            else:
                return visitor.visitChildren(self)




    def prog(self):

        localctx = RLangParser.ProgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_prog)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 42
            self.environmentDef()
            self.state = 43
            self.match(RLangParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EnvironmentDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KEYWORD_ENV(self):
            return self.getToken(RLangParser.KEYWORD_ENV, 0)

        def ID(self):
            return self.getToken(RLangParser.ID, 0)

        def LBRACE(self):
            return self.getToken(RLangParser.LBRACE, 0)

        def stateDef(self):
            return self.getTypedRuleContext(RLangParser.StateDefContext,0)


        def actionsDef(self):
            return self.getTypedRuleContext(RLangParser.ActionsDefContext,0)


        def RBRACE(self):
            return self.getToken(RLangParser.RBRACE, 0)

        def dynamicsDef(self):
            return self.getTypedRuleContext(RLangParser.DynamicsDefContext,0)


        def rewardsDef(self):
            return self.getTypedRuleContext(RLangParser.RewardsDefContext,0)


        def trainingDef(self):
            return self.getTypedRuleContext(RLangParser.TrainingDefContext,0)


        def getRuleIndex(self):
            return RLangParser.RULE_environmentDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnvironmentDef" ):
                listener.enterEnvironmentDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnvironmentDef" ):
                listener.exitEnvironmentDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEnvironmentDef" ):
                return visitor.visitEnvironmentDef(self)
            else:
                return visitor.visitChildren(self)




    def environmentDef(self):

        localctx = RLangParser.EnvironmentDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_environmentDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 45
            self.match(RLangParser.KEYWORD_ENV)
            self.state = 46
            self.match(RLangParser.ID)
            self.state = 47
            self.match(RLangParser.LBRACE)
            self.state = 48
            self.stateDef()
            self.state = 49
            self.actionsDef()
            self.state = 51
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==5:
                self.state = 50
                self.dynamicsDef()


            self.state = 54
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==6:
                self.state = 53
                self.rewardsDef()


            self.state = 57
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==7:
                self.state = 56
                self.trainingDef()


            self.state = 59
            self.match(RLangParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StateDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KEYWORD_STATE(self):
            return self.getToken(RLangParser.KEYWORD_STATE, 0)

        def LBRACE(self):
            return self.getToken(RLangParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(RLangParser.RBRACE, 0)

        def varDecl(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RLangParser.VarDeclContext)
            else:
                return self.getTypedRuleContext(RLangParser.VarDeclContext,i)


        def getRuleIndex(self):
            return RLangParser.RULE_stateDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStateDef" ):
                listener.enterStateDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStateDef" ):
                listener.exitStateDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStateDef" ):
                return visitor.visitStateDef(self)
            else:
                return visitor.visitChildren(self)




    def stateDef(self):

        localctx = RLangParser.StateDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_stateDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 61
            self.match(RLangParser.KEYWORD_STATE)
            self.state = 62
            self.match(RLangParser.LBRACE)
            self.state = 66
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==15:
                self.state = 63
                self.varDecl()
                self.state = 68
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 69
            self.match(RLangParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarDeclContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(RLangParser.ID, 0)

        def ASSIGN_COLON(self):
            return self.getToken(RLangParser.ASSIGN_COLON, 0)

        def type_(self):
            return self.getTypedRuleContext(RLangParser.TypeContext,0)


        def paramList(self):
            return self.getTypedRuleContext(RLangParser.ParamListContext,0)


        def SEMI(self):
            return self.getToken(RLangParser.SEMI, 0)

        def getRuleIndex(self):
            return RLangParser.RULE_varDecl

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVarDecl" ):
                listener.enterVarDecl(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVarDecl" ):
                listener.exitVarDecl(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarDecl" ):
                return visitor.visitVarDecl(self)
            else:
                return visitor.visitChildren(self)




    def varDecl(self):

        localctx = RLangParser.VarDeclContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_varDecl)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 71
            self.match(RLangParser.ID)
            self.state = 72
            self.match(RLangParser.ASSIGN_COLON)
            self.state = 73
            self.type_()
            self.state = 74
            self.paramList()
            self.state = 75
            self.match(RLangParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RLangParser.RULE_type

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ContinuousTypeContext(TypeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RLangParser.TypeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TYPE_CONT(self):
            return self.getToken(RLangParser.TYPE_CONT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContinuousType" ):
                listener.enterContinuousType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContinuousType" ):
                listener.exitContinuousType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitContinuousType" ):
                return visitor.visitContinuousType(self)
            else:
                return visitor.visitChildren(self)


    class DiscreteTypeContext(TypeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RLangParser.TypeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TYPE_DISC(self):
            return self.getToken(RLangParser.TYPE_DISC, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDiscreteType" ):
                listener.enterDiscreteType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDiscreteType" ):
                listener.exitDiscreteType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDiscreteType" ):
                return visitor.visitDiscreteType(self)
            else:
                return visitor.visitChildren(self)



    def type_(self):

        localctx = RLangParser.TypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_type)
        try:
            self.state = 79
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [13]:
                localctx = RLangParser.ContinuousTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 77
                self.match(RLangParser.TYPE_CONT)
                pass
            elif token in [14]:
                localctx = RLangParser.DiscreteTypeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 78
                self.match(RLangParser.TYPE_DISC)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ParamListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RLangParser.RULE_paramList

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ContinuousParamsContext(ParamListContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RLangParser.ParamListContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(RLangParser.LPAREN, 0)
        def RPAREN(self):
            return self.getToken(RLangParser.RPAREN, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RLangParser.ExprContext)
            else:
                return self.getTypedRuleContext(RLangParser.ExprContext,i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RLangParser.COMMA)
            else:
                return self.getToken(RLangParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterContinuousParams" ):
                listener.enterContinuousParams(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitContinuousParams" ):
                listener.exitContinuousParams(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitContinuousParams" ):
                return visitor.visitContinuousParams(self)
            else:
                return visitor.visitChildren(self)


    class DiscreteParamsContext(ParamListContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RLangParser.ParamListContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LBRACK(self):
            return self.getToken(RLangParser.LBRACK, 0)
        def RBRACK(self):
            return self.getToken(RLangParser.RBRACK, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RLangParser.ExprContext)
            else:
                return self.getTypedRuleContext(RLangParser.ExprContext,i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RLangParser.COMMA)
            else:
                return self.getToken(RLangParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDiscreteParams" ):
                listener.enterDiscreteParams(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDiscreteParams" ):
                listener.exitDiscreteParams(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDiscreteParams" ):
                return visitor.visitDiscreteParams(self)
            else:
                return visitor.visitChildren(self)



    def paramList(self):

        localctx = RLangParser.ParamListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_paramList)
        self._la = 0 # Token type
        try:
            self.state = 105
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [22]:
                localctx = RLangParser.ContinuousParamsContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 81
                self.match(RLangParser.LPAREN)
                self.state = 90
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 4292608) != 0):
                    self.state = 82
                    self.expr(0)
                    self.state = 87
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==21:
                        self.state = 83
                        self.match(RLangParser.COMMA)
                        self.state = 84
                        self.expr(0)
                        self.state = 89
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 92
                self.match(RLangParser.RPAREN)
                pass
            elif token in [26]:
                localctx = RLangParser.DiscreteParamsContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 93
                self.match(RLangParser.LBRACK)
                self.state = 102
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 4292608) != 0):
                    self.state = 94
                    self.expr(0)
                    self.state = 99
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==21:
                        self.state = 95
                        self.match(RLangParser.COMMA)
                        self.state = 96
                        self.expr(0)
                        self.state = 101
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 104
                self.match(RLangParser.RBRACK)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionsDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KEYWORD_ACTIONS(self):
            return self.getToken(RLangParser.KEYWORD_ACTIONS, 0)

        def LBRACE(self):
            return self.getToken(RLangParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(RLangParser.RBRACE, 0)

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(RLangParser.ID)
            else:
                return self.getToken(RLangParser.ID, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RLangParser.COMMA)
            else:
                return self.getToken(RLangParser.COMMA, i)

        def getRuleIndex(self):
            return RLangParser.RULE_actionsDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionsDef" ):
                listener.enterActionsDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionsDef" ):
                listener.exitActionsDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitActionsDef" ):
                return visitor.visitActionsDef(self)
            else:
                return visitor.visitChildren(self)




    def actionsDef(self):

        localctx = RLangParser.ActionsDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_actionsDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 107
            self.match(RLangParser.KEYWORD_ACTIONS)
            self.state = 108
            self.match(RLangParser.LBRACE)
            self.state = 117
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==15:
                self.state = 109
                self.match(RLangParser.ID)
                self.state = 114
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==21:
                    self.state = 110
                    self.match(RLangParser.COMMA)
                    self.state = 111
                    self.match(RLangParser.ID)
                    self.state = 116
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 119
            self.match(RLangParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DynamicsDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KEYWORD_DYNAMICS(self):
            return self.getToken(RLangParser.KEYWORD_DYNAMICS, 0)

        def LBRACE(self):
            return self.getToken(RLangParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(RLangParser.RBRACE, 0)

        def dynamicsRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RLangParser.DynamicsRuleContext)
            else:
                return self.getTypedRuleContext(RLangParser.DynamicsRuleContext,i)


        def getRuleIndex(self):
            return RLangParser.RULE_dynamicsDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDynamicsDef" ):
                listener.enterDynamicsDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDynamicsDef" ):
                listener.exitDynamicsDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDynamicsDef" ):
                return visitor.visitDynamicsDef(self)
            else:
                return visitor.visitChildren(self)




    def dynamicsDef(self):

        localctx = RLangParser.DynamicsDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_dynamicsDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            self.match(RLangParser.KEYWORD_DYNAMICS)
            self.state = 122
            self.match(RLangParser.LBRACE)
            self.state = 126
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==8 or _la==9:
                self.state = 123
                self.dynamicsRule()
                self.state = 128
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 129
            self.match(RLangParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DynamicsRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RLangParser.RULE_dynamicsRule

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class AlwaysRuleContext(DynamicsRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RLangParser.DynamicsRuleContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def KEYWORD_ALWAYS(self):
            return self.getToken(RLangParser.KEYWORD_ALWAYS, 0)
        def LBRACE(self):
            return self.getToken(RLangParser.LBRACE, 0)
        def statementList(self):
            return self.getTypedRuleContext(RLangParser.StatementListContext,0)

        def RBRACE(self):
            return self.getToken(RLangParser.RBRACE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlwaysRule" ):
                listener.enterAlwaysRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlwaysRule" ):
                listener.exitAlwaysRule(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlwaysRule" ):
                return visitor.visitAlwaysRule(self)
            else:
                return visitor.visitChildren(self)


    class WhenRuleContext(DynamicsRuleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RLangParser.DynamicsRuleContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def KEYWORD_WHEN(self):
            return self.getToken(RLangParser.KEYWORD_WHEN, 0)
        def LPAREN(self):
            return self.getToken(RLangParser.LPAREN, 0)
        def condition(self):
            return self.getTypedRuleContext(RLangParser.ConditionContext,0)

        def RPAREN(self):
            return self.getToken(RLangParser.RPAREN, 0)
        def LBRACE(self):
            return self.getToken(RLangParser.LBRACE, 0)
        def statementList(self):
            return self.getTypedRuleContext(RLangParser.StatementListContext,0)

        def RBRACE(self):
            return self.getToken(RLangParser.RBRACE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhenRule" ):
                listener.enterWhenRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhenRule" ):
                listener.exitWhenRule(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhenRule" ):
                return visitor.visitWhenRule(self)
            else:
                return visitor.visitChildren(self)



    def dynamicsRule(self):

        localctx = RLangParser.DynamicsRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_dynamicsRule)
        try:
            self.state = 144
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [8]:
                localctx = RLangParser.AlwaysRuleContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 131
                self.match(RLangParser.KEYWORD_ALWAYS)
                self.state = 132
                self.match(RLangParser.LBRACE)
                self.state = 133
                self.statementList()
                self.state = 134
                self.match(RLangParser.RBRACE)
                pass
            elif token in [9]:
                localctx = RLangParser.WhenRuleContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 136
                self.match(RLangParser.KEYWORD_WHEN)
                self.state = 137
                self.match(RLangParser.LPAREN)
                self.state = 138
                self.condition()
                self.state = 139
                self.match(RLangParser.RPAREN)
                self.state = 140
                self.match(RLangParser.LBRACE)
                self.state = 141
                self.statementList()
                self.state = 142
                self.match(RLangParser.RBRACE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementListContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RLangParser.StatementContext)
            else:
                return self.getTypedRuleContext(RLangParser.StatementContext,i)


        def getRuleIndex(self):
            return RLangParser.RULE_statementList

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatementList" ):
                listener.enterStatementList(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatementList" ):
                listener.exitStatementList(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatementList" ):
                return visitor.visitStatementList(self)
            else:
                return visitor.visitChildren(self)




    def statementList(self):

        localctx = RLangParser.StatementListContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_statementList)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 149
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & 16813056) != 0):
                self.state = 146
                self.statement()
                self.state = 151
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assignment(self):
            return self.getTypedRuleContext(RLangParser.AssignmentContext,0)


        def SEMI(self):
            return self.getToken(RLangParser.SEMI, 0)

        def ifStatement(self):
            return self.getTypedRuleContext(RLangParser.IfStatementContext,0)


        def matchStatement(self):
            return self.getTypedRuleContext(RLangParser.MatchStatementContext,0)


        def LBRACE(self):
            return self.getToken(RLangParser.LBRACE, 0)

        def statementList(self):
            return self.getTypedRuleContext(RLangParser.StatementListContext,0)


        def RBRACE(self):
            return self.getToken(RLangParser.RBRACE, 0)

        def getRuleIndex(self):
            return RLangParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = RLangParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_statement)
        try:
            self.state = 168
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [15]:
                self.enterOuterAlt(localctx, 1)
                self.state = 152
                self.assignment()
                self.state = 154
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
                if la_ == 1:
                    self.state = 153
                    self.match(RLangParser.SEMI)


                pass
            elif token in [11]:
                self.enterOuterAlt(localctx, 2)
                self.state = 156
                self.ifStatement()
                self.state = 158
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,16,self._ctx)
                if la_ == 1:
                    self.state = 157
                    self.match(RLangParser.SEMI)


                pass
            elif token in [10]:
                self.enterOuterAlt(localctx, 3)
                self.state = 160
                self.matchStatement()
                self.state = 162
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
                if la_ == 1:
                    self.state = 161
                    self.match(RLangParser.SEMI)


                pass
            elif token in [24]:
                self.enterOuterAlt(localctx, 4)
                self.state = 164
                self.match(RLangParser.LBRACE)
                self.state = 165
                self.statementList()
                self.state = 166
                self.match(RLangParser.RBRACE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AssignmentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(RLangParser.ID, 0)

        def ASSIGN_EQ(self):
            return self.getToken(RLangParser.ASSIGN_EQ, 0)

        def expr(self):
            return self.getTypedRuleContext(RLangParser.ExprContext,0)


        def SEMI(self):
            return self.getToken(RLangParser.SEMI, 0)

        def getRuleIndex(self):
            return RLangParser.RULE_assignment

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignment" ):
                listener.enterAssignment(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignment" ):
                listener.exitAssignment(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAssignment" ):
                return visitor.visitAssignment(self)
            else:
                return visitor.visitChildren(self)




    def assignment(self):

        localctx = RLangParser.AssignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_assignment)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 170
            self.match(RLangParser.ID)
            self.state = 171
            self.match(RLangParser.ASSIGN_EQ)
            self.state = 172
            self.expr(0)
            self.state = 174
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
            if la_ == 1:
                self.state = 173
                self.match(RLangParser.SEMI)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IfStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KEYWORD_IF(self):
            return self.getToken(RLangParser.KEYWORD_IF, 0)

        def LPAREN(self):
            return self.getToken(RLangParser.LPAREN, 0)

        def condition(self):
            return self.getTypedRuleContext(RLangParser.ConditionContext,0)


        def RPAREN(self):
            return self.getToken(RLangParser.RPAREN, 0)

        def statement(self):
            return self.getTypedRuleContext(RLangParser.StatementContext,0)


        def getRuleIndex(self):
            return RLangParser.RULE_ifStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIfStatement" ):
                listener.enterIfStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIfStatement" ):
                listener.exitIfStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIfStatement" ):
                return visitor.visitIfStatement(self)
            else:
                return visitor.visitChildren(self)




    def ifStatement(self):

        localctx = RLangParser.IfStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_ifStatement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 176
            self.match(RLangParser.KEYWORD_IF)
            self.state = 177
            self.match(RLangParser.LPAREN)
            self.state = 178
            self.condition()
            self.state = 179
            self.match(RLangParser.RPAREN)
            self.state = 180
            self.statement()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatchStatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KEYWORD_MATCH(self):
            return self.getToken(RLangParser.KEYWORD_MATCH, 0)

        def KEYWORD_ACTION(self):
            return self.getToken(RLangParser.KEYWORD_ACTION, 0)

        def LBRACE(self):
            return self.getToken(RLangParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(RLangParser.RBRACE, 0)

        def matchCase(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RLangParser.MatchCaseContext)
            else:
                return self.getTypedRuleContext(RLangParser.MatchCaseContext,i)


        def getRuleIndex(self):
            return RLangParser.RULE_matchStatement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatchStatement" ):
                listener.enterMatchStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatchStatement" ):
                listener.exitMatchStatement(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatchStatement" ):
                return visitor.visitMatchStatement(self)
            else:
                return visitor.visitChildren(self)




    def matchStatement(self):

        localctx = RLangParser.MatchStatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_matchStatement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 182
            self.match(RLangParser.KEYWORD_MATCH)
            self.state = 183
            self.match(RLangParser.KEYWORD_ACTION)
            self.state = 184
            self.match(RLangParser.LBRACE)
            self.state = 188
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==15:
                self.state = 185
                self.matchCase()
                self.state = 190
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 191
            self.match(RLangParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MatchCaseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(RLangParser.ID, 0)

        def ARROW(self):
            return self.getToken(RLangParser.ARROW, 0)

        def statement(self):
            return self.getTypedRuleContext(RLangParser.StatementContext,0)


        def SEMI(self):
            return self.getToken(RLangParser.SEMI, 0)

        def getRuleIndex(self):
            return RLangParser.RULE_matchCase

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMatchCase" ):
                listener.enterMatchCase(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMatchCase" ):
                listener.exitMatchCase(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMatchCase" ):
                return visitor.visitMatchCase(self)
            else:
                return visitor.visitChildren(self)




    def matchCase(self):

        localctx = RLangParser.MatchCaseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_matchCase)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 193
            self.match(RLangParser.ID)
            self.state = 194
            self.match(RLangParser.ARROW)
            self.state = 195
            self.statement()
            self.state = 196
            self.match(RLangParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RewardsDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KEYWORD_REWARDS(self):
            return self.getToken(RLangParser.KEYWORD_REWARDS, 0)

        def LBRACE(self):
            return self.getToken(RLangParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(RLangParser.RBRACE, 0)

        def rewardRule(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RLangParser.RewardRuleContext)
            else:
                return self.getTypedRuleContext(RLangParser.RewardRuleContext,i)


        def getRuleIndex(self):
            return RLangParser.RULE_rewardsDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRewardsDef" ):
                listener.enterRewardsDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRewardsDef" ):
                listener.exitRewardsDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRewardsDef" ):
                return visitor.visitRewardsDef(self)
            else:
                return visitor.visitChildren(self)




    def rewardsDef(self):

        localctx = RLangParser.RewardsDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_rewardsDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 198
            self.match(RLangParser.KEYWORD_REWARDS)
            self.state = 199
            self.match(RLangParser.LBRACE)
            self.state = 203
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==11:
                self.state = 200
                self.rewardRule()
                self.state = 205
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 206
            self.match(RLangParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RewardRuleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KEYWORD_IF(self):
            return self.getToken(RLangParser.KEYWORD_IF, 0)

        def LPAREN(self):
            return self.getToken(RLangParser.LPAREN, 0)

        def condition(self):
            return self.getTypedRuleContext(RLangParser.ConditionContext,0)


        def RPAREN(self):
            return self.getToken(RLangParser.RPAREN, 0)

        def ARROW(self):
            return self.getToken(RLangParser.ARROW, 0)

        def expr(self):
            return self.getTypedRuleContext(RLangParser.ExprContext,0)


        def SEMI(self):
            return self.getToken(RLangParser.SEMI, 0)

        def getRuleIndex(self):
            return RLangParser.RULE_rewardRule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRewardRule" ):
                listener.enterRewardRule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRewardRule" ):
                listener.exitRewardRule(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRewardRule" ):
                return visitor.visitRewardRule(self)
            else:
                return visitor.visitChildren(self)




    def rewardRule(self):

        localctx = RLangParser.RewardRuleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_rewardRule)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 208
            self.match(RLangParser.KEYWORD_IF)
            self.state = 209
            self.match(RLangParser.LPAREN)
            self.state = 210
            self.condition()
            self.state = 211
            self.match(RLangParser.RPAREN)
            self.state = 212
            self.match(RLangParser.ARROW)
            self.state = 213
            self.expr(0)
            self.state = 214
            self.match(RLangParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TrainingDefContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def KEYWORD_TRAINING(self):
            return self.getToken(RLangParser.KEYWORD_TRAINING, 0)

        def LBRACE(self):
            return self.getToken(RLangParser.LBRACE, 0)

        def RBRACE(self):
            return self.getToken(RLangParser.RBRACE, 0)

        def configAssign(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RLangParser.ConfigAssignContext)
            else:
                return self.getTypedRuleContext(RLangParser.ConfigAssignContext,i)


        def getRuleIndex(self):
            return RLangParser.RULE_trainingDef

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrainingDef" ):
                listener.enterTrainingDef(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrainingDef" ):
                listener.exitTrainingDef(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrainingDef" ):
                return visitor.visitTrainingDef(self)
            else:
                return visitor.visitChildren(self)




    def trainingDef(self):

        localctx = RLangParser.TrainingDefContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_trainingDef)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 216
            self.match(RLangParser.KEYWORD_TRAINING)
            self.state = 217
            self.match(RLangParser.LBRACE)
            self.state = 221
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==15:
                self.state = 218
                self.configAssign()
                self.state = 223
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 224
            self.match(RLangParser.RBRACE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConfigAssignContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(RLangParser.ID, 0)

        def ASSIGN_COLON(self):
            return self.getToken(RLangParser.ASSIGN_COLON, 0)

        def expr(self):
            return self.getTypedRuleContext(RLangParser.ExprContext,0)


        def SEMI(self):
            return self.getToken(RLangParser.SEMI, 0)

        def getRuleIndex(self):
            return RLangParser.RULE_configAssign

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConfigAssign" ):
                listener.enterConfigAssign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConfigAssign" ):
                listener.exitConfigAssign(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConfigAssign" ):
                return visitor.visitConfigAssign(self)
            else:
                return visitor.visitChildren(self)




    def configAssign(self):

        localctx = RLangParser.ConfigAssignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_configAssign)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 226
            self.match(RLangParser.ID)
            self.state = 227
            self.match(RLangParser.ASSIGN_COLON)
            self.state = 228
            self.expr(0)
            self.state = 229
            self.match(RLangParser.SEMI)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConditionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RLangParser.RULE_condition

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class SimpleConditionContext(ConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RLangParser.ConditionContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RLangParser.ExprContext)
            else:
                return self.getTypedRuleContext(RLangParser.ExprContext,i)

        def EQ(self):
            return self.getToken(RLangParser.EQ, 0)
        def NEQ(self):
            return self.getToken(RLangParser.NEQ, 0)
        def GT(self):
            return self.getToken(RLangParser.GT, 0)
        def LT(self):
            return self.getToken(RLangParser.LT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSimpleCondition" ):
                listener.enterSimpleCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSimpleCondition" ):
                listener.exitSimpleCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimpleCondition" ):
                return visitor.visitSimpleCondition(self)
            else:
                return visitor.visitChildren(self)


    class ActionInListConditionContext(ConditionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RLangParser.ConditionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(RLangParser.ID, 0)
        def IN(self):
            return self.getToken(RLangParser.IN, 0)
        def LBRACK(self):
            return self.getToken(RLangParser.LBRACK, 0)
        def RBRACK(self):
            return self.getToken(RLangParser.RBRACK, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RLangParser.ExprContext)
            else:
                return self.getTypedRuleContext(RLangParser.ExprContext,i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(RLangParser.COMMA)
            else:
                return self.getToken(RLangParser.COMMA, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterActionInListCondition" ):
                listener.enterActionInListCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitActionInListCondition" ):
                listener.exitActionInListCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitActionInListCondition" ):
                return visitor.visitActionInListCondition(self)
            else:
                return visitor.visitChildren(self)



    def condition(self):

        localctx = RLangParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_condition)
        self._la = 0 # Token type
        try:
            self.state = 249
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                localctx = RLangParser.ActionInListConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 231
                self.match(RLangParser.ID)
                self.state = 232
                self.match(RLangParser.IN)
                self.state = 233
                self.match(RLangParser.LBRACK)
                self.state = 242
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & 4292608) != 0):
                    self.state = 234
                    self.expr(0)
                    self.state = 239
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==21:
                        self.state = 235
                        self.match(RLangParser.COMMA)
                        self.state = 236
                        self.expr(0)
                        self.state = 241
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 244
                self.match(RLangParser.RBRACK)
                pass

            elif la_ == 2:
                localctx = RLangParser.SimpleConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 245
                self.expr(0)
                self.state = 246
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & 8053063680) != 0)):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 247
                self.expr(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return RLangParser.RULE_expr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class IdExprContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RLangParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(RLangParser.ID, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdExpr" ):
                listener.enterIdExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdExpr" ):
                listener.exitIdExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIdExpr" ):
                return visitor.visitIdExpr(self)
            else:
                return visitor.visitChildren(self)


    class NumberExprContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RLangParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NUMBER(self):
            return self.getToken(RLangParser.NUMBER, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNumberExpr" ):
                listener.enterNumberExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNumberExpr" ):
                listener.exitNumberExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNumberExpr" ):
                return visitor.visitNumberExpr(self)
            else:
                return visitor.visitChildren(self)


    class MulDivContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RLangParser.ExprContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RLangParser.ExprContext)
            else:
                return self.getTypedRuleContext(RLangParser.ExprContext,i)

        def MUL(self):
            return self.getToken(RLangParser.MUL, 0)
        def DIV(self):
            return self.getToken(RLangParser.DIV, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMulDiv" ):
                listener.enterMulDiv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMulDiv" ):
                listener.exitMulDiv(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMulDiv" ):
                return visitor.visitMulDiv(self)
            else:
                return visitor.visitChildren(self)


    class AddSubContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RLangParser.ExprContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(RLangParser.ExprContext)
            else:
                return self.getTypedRuleContext(RLangParser.ExprContext,i)

        def PLUS(self):
            return self.getToken(RLangParser.PLUS, 0)
        def MINUS(self):
            return self.getToken(RLangParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAddSub" ):
                listener.enterAddSub(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAddSub" ):
                listener.exitAddSub(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAddSub" ):
                return visitor.visitAddSub(self)
            else:
                return visitor.visitChildren(self)


    class ParenExprContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a RLangParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def LPAREN(self):
            return self.getToken(RLangParser.LPAREN, 0)
        def expr(self):
            return self.getTypedRuleContext(RLangParser.ExprContext,0)

        def RPAREN(self):
            return self.getToken(RLangParser.RPAREN, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterParenExpr" ):
                listener.enterParenExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitParenExpr" ):
                listener.exitParenExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParenExpr" ):
                return visitor.visitParenExpr(self)
            else:
                return visitor.visitChildren(self)



    def expr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = RLangParser.ExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 40
        self.enterRecursionRule(localctx, 40, self.RULE_expr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 258
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [15]:
                localctx = RLangParser.IdExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 252
                self.match(RLangParser.ID)
                pass
            elif token in [16]:
                localctx = RLangParser.NumberExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 253
                self.match(RLangParser.NUMBER)
                pass
            elif token in [22]:
                localctx = RLangParser.ParenExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 254
                self.match(RLangParser.LPAREN)
                self.state = 255
                self.expr(0)
                self.state = 256
                self.match(RLangParser.RPAREN)
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 268
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,28,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 266
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
                    if la_ == 1:
                        localctx = RLangParser.MulDivContext(self, RLangParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 260
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 261
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==35 or _la==36):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 262
                        self.expr(6)
                        pass

                    elif la_ == 2:
                        localctx = RLangParser.AddSubContext(self, RLangParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 263
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 264
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==33 or _la==34):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 265
                        self.expr(5)
                        pass

             
                self.state = 270
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,28,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[20] = self.expr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expr_sempred(self, localctx:ExprContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 4)
         




